(****************************************************************
 * ASL utility functions
 *
 * Copyright Arm Limited (c) 2017-2019
 * Copyright (C) 2022-2025 Intel Corporation
 * SPDX-Licence-Identifier: BSD-3-Clause
 ****************************************************************)

(** ASL utility functions *)

module AST = Asl_ast
module FMT = Asl_fmt
module FMTUtils = Format_utils
open Builtin_idents
open AST
open Asl_visitor
open Identset

(****************************************************************)
(** {2 Name supply}                                             *)
(****************************************************************)

(* This is used to generate unique names by generating a new name
 * each time it is invoked.
 *
 * Uniqueness depends on
 * - the prefix being different from names in the original source
 *   code and different from names generated by other nameSupply
 *   instances.
 * - in almost all cases, the class should be instantiated as a global
 *   variable so that all names are unique across the entire application.
 *)
class nameSupply (prefix : string) =
  object
    val mutable vnum = 0

    method fresh : Ident.t =
      let v = Ident.mk_ident (prefix ^ string_of_int vnum) in
      vnum <- vnum + 1;
      v

    method reset : unit =
      vnum <- 0
  end

(****************************************************************)
(** {2 Equivalence classes}                                     *)
(****************************************************************)

type tree = { mutable parent : tree; data : Ident.t }
(** Equivalence classes are represented by trees.

    The root of the tree is the canonical member of the class.
    Traversing the parent node takes you closer to the canonical member.
    The root is its own parent.
 *)

(** Equivalence class support (to support unification, and similar)

    The implementation is based on
    {{:https://en.wikipedia.org/wiki/Disjoint-set_data_structure}Wikipedia: Union-Find}.
    I have not implemented all the optimizations they suggest
    because I expect sets to be quite small in practice.
 *)

class equivalences =
  object (self)
    (* Mapping from elements to the set containing them *)
    val mutable forest : tree Bindings.t = Bindings.empty

    (* Find the root (canonical member of) the set.
     * Implements "path-splitting" optimisation that makes every node
     * point to its grandfather so each traversal reduces height of tree.
     *
     * Efficiency of this data structure critically depends on the
     * use of pointer equality in the search.
     *)
    method private find (x : tree) : tree =
      let r = ref x in
      while !r.parent != !r do
        let next = !r.parent in
        !r.parent <- next.parent;
        r := next
      done;
      !r

    (* Find the root of the set containing 'x' - creating a new
     * set if not already known *)
    method private find_ident (x : Ident.t) : tree =
      let s =
        match Bindings.find_opt x forest with
        | None ->
            let rec t = { parent = t; data = x } in
            t
        | Some t -> self#find t
      in
      forest <- Bindings.add x s forest;
      s

    (* Find the canonical member of the set containing 'x' *)
    method canonicalize (x : Ident.t) : Ident.t =
      let s = self#find_ident x in
      s.data

    (* Merge the sets containing 'x' and 'y'
     *
     * Efficiency of this data structure critically depends on the
     * use of pointer equality when merging nodes.
     *)
    method merge (x : Ident.t) (y : Ident.t) : unit =
      let x' = self#find_ident x in
      let y' = self#find_ident y in
      if x != y then y'.parent <- x'

    (* Optimization: short circuit every tree so that they all point directly at
       root *)
    method private normalize : unit = forest <- Bindings.map self#find forest

    (* Return mapping from identifiers to the canonical representation of their
     * equivalence class
     *)
    method mapping : Ident.t Bindings.t =
      self#normalize;
      Bindings.map (fun t -> (self#find t).data) forest

    (* Construct equivalence classes for each canonical member of a class.
     *
     * The implementation of this could be made more efficient by adding
     * pointers to trees so that we can map each canonical member to a
     * tree containing all the nodes that point to it.
     * But this implementation just does a linear scan over all the members
     * of the forest.
     *)
    method classes : IdentSet.t Bindings.t =
      Bindings.fold (fun k v -> addToBindingSet v k) self#mapping Bindings.empty

    (* Print equivalence classes adding a prefix at the start of every line of
     * output.
     *)
    method pp (fmt : Format.formatter) (prefix : string) : unit =
      Format.pp_open_vbox fmt 0;
      Bindings.iter
        (fun v vs ->
          Format.pp_print_string fmt prefix;
          FMT.varname fmt v;
          Format.fprintf fmt "-> {";
          IdentSet.iter
            (fun w ->
              FMT.varname fmt w;
              FMTUtils.nbsp fmt)
            vs;
          Format.fprintf fmt "}";
          Format.pp_print_space fmt ())
        self#classes;
      Format.pp_close_box fmt ()
  end

(****************************************************************)
(** {1 AST Transformation Utilities}                            *)
(****************************************************************)

(****************************************************************)
(** {2 Calculating free variables of expressions and types}     *)
(****************************************************************)

class freevarClass =
  object
    inherit nopAslVisitor
    val mutable free_vars = IdentSet.empty
    val mutable free_tcs = IdentSet.empty
    val mutable free_funs = IdentSet.empty
    method vars = free_vars
    method tycons = free_tcs
    method funs = free_funs

    method! vvar access x =
      if access = Read then free_vars <- IdentSet.add x free_vars;
      SkipChildren

    method! vtype ty =
      match ty with
      | Type_Constructor (tc, _) ->
          free_tcs <- IdentSet.add tc free_tcs;
          DoChildren
      | Type_Bits (_, fs) when not (Utils.is_empty fs) ->
          (* Free variables in register types are not supported and will
             lead to a type error.

             Uses of global constants and variables in the indices of field
             declarations of a register type are allowed, though, and will
             be checked by the type checker as usual.  Note that they will
             not be evaluated at register declaration time, but every time
             the respective register field is accessed (the type checker
             desugars register field accesses to slice expressions, copying
             the field indices). *)
          SkipChildren
      | _ -> DoChildren

    method! vexpr e =
      match e with
      | Expr_UApply (f, _, _) ->
          free_funs <- IdentSet.add f free_funs;
          DoChildren
      | Expr_TApply (f, _, _, _) ->
          free_funs <- IdentSet.add f free_funs;
          DoChildren
      | Expr_Record (tc, _, _) ->
          free_tcs <- IdentSet.add tc free_tcs;
          DoChildren
      | _ -> DoChildren

    method! vlexpr =
      function
      | LExpr_Var v ->
          free_vars <- IdentSet.add v free_vars;
          SkipChildren
      | LExpr_Write (f, _, _, _) ->
          free_funs <- IdentSet.add f free_funs;
          DoChildren
      | LExpr_ReadWrite (f, g, _, _, _) ->
          free_funs <- IdentSet.add f free_funs;
          free_funs <- IdentSet.add g free_funs;
          DoChildren
      | _ -> DoChildren

    method! vstmt s =
      match s with
      | Stmt_UCall (f, _, _, _) ->
          free_funs <- IdentSet.add f free_funs;
          DoChildren
      | Stmt_TCall (f, _, _, _, _) ->
          free_funs <- IdentSet.add f free_funs;
          DoChildren
      | _ -> DoChildren

    method! vcatcher (Catcher_Guarded (_, tc, _, _)) =
      free_tcs <- IdentSet.add tc free_tcs;
      DoChildren

    method! leave_scope (vs : Ident.t list) =
      (* remove reads/writes to local variables *)
      List.iter (fun v -> free_vars <- IdentSet.remove v free_vars) vs
  end

let fv_expr (x : expr) : IdentSet.t =
  let fv = new freevarClass in
  ignore (visit_expr (fv :> aslVisitor) x);
  fv#vars

let fv_type (x : ty) : IdentSet.t =
  let fv = new freevarClass in
  ignore (visit_type (fv :> aslVisitor) x);
  fv#vars

let fv_types (xs : ty list) : IdentSet.t =
  unionSets (List.map fv_type xs)

let fv_stmts stmts =
  let fvs = new freevarClass in
  ignore (visit_stmts (fvs :> aslVisitor) stmts);
  fvs#vars

let fv_decl decl =
  let fvs = new freevarClass in
  ignore (visit_decl (fvs :> aslVisitor) decl);
  fvs#vars

(****************************************************************)
(** {2 Calculating assigned variables in statements}            *)
(****************************************************************)

class assignedVarsClass =
  object
    inherit nopAslVisitor
    val mutable avs = IdentSet.empty
    method result = avs

    method! vlvar x =
      avs <- IdentSet.add x avs;
      SkipChildren
  end

let assigned_vars_of_stmts stmts =
  let avs = new assignedVarsClass in
  ignore (visit_stmts (avs :> aslVisitor) stmts);
  avs#result

let assigned_vars_of_decl decl =
  let avs = new assignedVarsClass in
  ignore (visit_decl (avs :> aslVisitor) decl);
  avs#result

(****************************************************************)
(** {2 Calculating subexpressions}                              *)
(****************************************************************)

(** Collect subexpressions of an expression *)
class subExprsClass (root : expr) =
  object
    inherit nopAslVisitor
    val mutable exprs : expr list = []
    method result = exprs

    method! vexpr x =
      (* Use of pointer equality (==) is deliberate here.
       * We are only interested in checking for the root object itself
       * not some object that is structurally identical to it
       * and we don't want to avoid the quadratic cost that would occur
       * if we performed a structural equality check as we recurse down
       * the tree.
       *)
      if x == root then DoChildren
      else (
        exprs <- x :: exprs;
        SkipChildren)
  end

let subexprs_of_expr (x : expr) : expr list =
  let subs = new subExprsClass x in
  ignore (visit_expr (subs :> aslVisitor) x);
  subs#result

(****************************************************************)
(** {2 Collect local bindings (variables and constants)}        *)
(****************************************************************)

(*
class localsClass = object (self)
    inherit nopAslVisitor

    val mutable stack = [(Bindings.empty : ty Bindings.t)]
    method locals =
        let merge _ x y = Some x in
        List.fold_right (Bindings.union merge) stack Bindings.empty

    method add_local (id, ty) =
        match stack with
        | s :: ss -> stack <- (Bindings.add id ty s :: ss)
        | [] -> failwith "addLocal: empty stack"
    method! enter_scope vars =
        stack <- Bindings.empty :: stack;
        List.iter self#add_local vars
    method! leave_scope () =
        match stack with
        | s :: ss -> stack <- ss
        | [] -> failwith "leave_scope: empty stack"
    method! vstmt = function
        | Stmt_VarDecl (_, id, ty, _, _)
            self#add_local (id, ty);
            DoChildren
        | Stmt_VarDeclsNoInit (ids, ty, _) ->
            List.iter (fun id -> self#add_local (id, ty)) ids;
            DoChildren
        | _ ->
            DoChildren
end

let locals_of_stmts stmts =
    let lc = new localsClass in
    ignore (Visitor.mapNoCopy (visit_stmt (lc :> aslVisitor)) stmts);
    lc#locals

let locals_of_decl decl =
    let lc = new localsClass in
    ignore (Visitor.mapNoCopy (visit_decl (lc :> aslVisitor)) decl);
    lc#locals
*)

(****************************************************************)
(** {2 Calculate types used in expressions and statements}      *)
(****************************************************************)

class typesClass =
  object
    inherit nopAslVisitor
    val mutable types = IdentSet.empty
    method result = types

    method! vtype ty =
      match ty with
      | Type_Constructor (id, _) ->
          types <- IdentSet.add id types;
          DoChildren
      | _ -> DoChildren
  end

let types_of_expr expr =
  let cc = new typesClass in
  ignore (visit_expr (cc :> aslVisitor) expr);
  cc#result

let types_of_stmts stmts =
  let cc = new typesClass in
  ignore (visit_stmts (cc :> aslVisitor) stmts);
  cc#result

let types_of_decl decl =
  let cc = new typesClass in
  ignore (visit_decl (cc :> aslVisitor) decl);
  cc#result

(****************************************************************)
(** {2 Calculate functions and procedures called in statements} *)
(****************************************************************)

class callsClass =
  object
    inherit nopAslVisitor
    val mutable calls = IdentSet.empty
    method result = calls

    method! vexpr =
      function
      | Expr_TApply (f, _, _, _) ->
          calls <- IdentSet.add f calls;
          DoChildren
      | _ -> DoChildren

    method! vstmt =
      function
      | Stmt_TCall (id, _, _, _, _) ->
          calls <- IdentSet.add id calls;
          DoChildren
      | _ -> DoChildren

    method! vlexpr =
      function
      | LExpr_Write (id, _, _, _) ->
          calls <- IdentSet.add id calls;
          DoChildren
      | LExpr_ReadWrite (id1, id2, _, _, _) ->
          calls <- IdentSet.add id1 calls |> IdentSet.add id2;
          DoChildren
      | _ -> DoChildren
  end

let calls_of_expr expr =
  let cc = new callsClass in
  ignore (visit_expr (cc :> aslVisitor) expr);
  cc#result

let calls_of_stmts stmts =
  let cc = new callsClass in
  ignore (visit_stmts (cc :> aslVisitor) stmts);
  cc#result

let calls_of_decl decl =
  let cc = new callsClass in
  ignore (visit_decl (cc :> aslVisitor) decl);
  cc#result

(****************************************************************)
(** {2 Extract location info from AST nodes}                    *)
(****************************************************************)

let decl_loc (x : AST.declaration) : Loc.t =
  ( match x with
  | Decl_BuiltinType (v, loc) -> loc
  | Decl_Forward (v, loc) -> loc
  | Decl_Record (v, ps, fs, loc) -> loc
  | Decl_Exception (v, fs, loc) -> loc
  | Decl_Typedef (v, ps, ty, loc) -> loc
  | Decl_Enum (v, es, loc) -> loc
  | Decl_Var (v, ty, loc) -> loc
  | Decl_Const (v, ty, e, loc) -> loc
  | Decl_BuiltinFunction (f, fty, loc) -> loc
  | Decl_FunType (f, fty, loc) -> loc
  | Decl_FunDefn (f, fty, b, loc) -> loc
  | Decl_Operator1 (op, vs, loc) -> loc
  | Decl_Operator2 (op, vs, loc) -> loc
  | Decl_Config (v, ty, e, loc) -> loc
  )

let stmt_loc (x : AST.stmt) : Loc.t =
  ( match x with
  | Stmt_VarDeclsNoInit (vs, ty, loc) -> loc
  | Stmt_VarDecl (_, di, i, loc) -> loc
  | Stmt_Assign (l, r, loc) -> loc
  | Stmt_TCall (f, tes, args, throws, loc) -> loc
  | Stmt_UCall (f, args, throws, loc) -> loc
  | Stmt_Return (e, loc) -> loc
  | Stmt_Assert (e, loc) -> loc
  | Stmt_Throw (v, loc) -> loc
  | Stmt_Block (b, loc) -> loc
  | Stmt_If (els, (e, el), loc) -> loc
  | Stmt_Case (e, oty, alts, ob, loc) -> loc
  | Stmt_For (v, ty, f, dir, t, b, loc) -> loc
  | Stmt_While (c, b, loc) -> loc
  | Stmt_Repeat (b, c, pos, loc) -> loc
  | Stmt_Try (b, pos, cs, ob, loc) -> loc
  )

(****************************************************************)
(** {2 Keep definitions reachable from roots}                   *)
(****************************************************************)

let decl_name (x : declaration) : Ident.t option =
  match x with
  | Decl_BuiltinType (v, loc) -> Some v
  | Decl_Forward (v, loc) -> Some v
  | Decl_Record (v, ps, fs, loc) -> Some v
  | Decl_Exception (v, fs, loc) -> Some v
  | Decl_Typedef (v, ps, ty, loc) -> Some v
  | Decl_Enum (v, es, loc) -> Some v
  | Decl_Var (v, ty, loc) -> Some v
  | Decl_Const (v, ty, e, loc) -> Some v
  | Decl_BuiltinFunction (f, fty, loc) -> Some f
  | Decl_FunType (f, fty, loc) -> Some f
  | Decl_FunDefn (f, fty, b, loc) -> Some f
  | Decl_Operator1 (op, vs, loc) -> None
  | Decl_Operator2 (op, vs, loc) -> None
  | Decl_Config (v, ty, e, loc) -> Some v

(** Similar to decl_name but for declarations that are monomorphizable *)
let monomorphizable_decl_name (d : AST.declaration) : Ident.t option =
  match d with
  | Decl_Record (v, ps, fs, loc) -> Some v
  | Decl_Typedef (v, ps, ty, loc) -> Some v
  | Decl_FunDefn (f, fty, b, loc) -> Some f
  | _ -> None

let monomorphizable_decl_to_ident_and_decl (d : AST.declaration) : (Ident.t * AST.declaration) option =
  monomorphizable_decl_name d |> Option.map (fun i -> (i, d))

(** Create mapping from identifiers to all declarations with that name.
 *
 * There can be multiple declarations with the same name so construct a map
 * from names to a list of declarations.
 *)
let decls_map_of (ds : declaration list) : (declaration list) Bindings.t =
  let decls_assoc : (Ident.t * declaration list) list =
    List.filter_map (fun d -> Option.map (fun nm -> (nm, [d])) (decl_name d)) ds
  in
  list_to_bindings List.append [] decls_assoc

(* construct map of Union { x -> f x | for x in xs } *)
let memoize (xs : Ident.t list) (f : Ident.t -> IdentSet.t) : IdentSet.t Bindings.t
    =
  let results = ref Bindings.empty in
  List.iter (fun x -> results := Bindings.add x (f x) !results) xs;
  !results

(* construct map of Union { f x -> x | for x in xs } *)
let rev_memoize (xs : Ident.t list) (f : Ident.t -> IdentSet.t) :
    IdentSet.t Bindings.t =
  let results = ref Bindings.empty in
  List.iter
    (fun x ->
      let ys = f x in
      IdentSet.iter
        (fun y ->
          let prev =
            Option.value (Bindings.find_opt y !results) ~default:IdentSet.empty
          in
          results := Bindings.add y (IdentSet.add x prev) !results)
        ys)
    xs;
  !results

(* Generate list of objects reachable from roots
 *
 * If the graph is acyclic, the resulting list will be
 * sorted in topological order such that 'x' occurs before 'y'
 * in the result if 'y' is transitively reachable from 'x'.
 * (Note that this is the reverse of the order that is
 * needed for code generation.)
 *
 * If the graph is cyclic, there are no ordering guarantees.
 *)
let reach (next : Ident.t -> IdentSet.t) (roots : Ident.t list) : Ident.t list =
  let result : Ident.t list ref = ref [] in
  let visited = ref IdentSet.empty in

  let rec dfs (x : Ident.t) : unit =
    if not (IdentSet.mem x !visited) then begin
      visited := IdentSet.add x !visited;
      IdentSet.iter dfs (next x);
      result := x :: !result
    end
  in

  List.iter dfs roots;
  !result

(* Convert bindings to a function (using a default value for absent values *)
let bindings_to_function (bs : 'a Bindings.t) (default : 'a) (x : Ident.t) : 'a =
  Option.value
    (Bindings.find_opt x bs)
    ~default:default

(* Generate list of declarations reachable from roots
 *
 * If the graph is acyclic, the resulting list will be
 * sorted in topological order such that 'x' occurs before 'y'
 * in the result if 'y' is transitively reachable from 'x'.
 * (Note that this is the reverse of the order that is
 * needed for code generation.)
 *
 * If the graph is cyclic, there are no ordering guarantees.
 *)
let reachable_decls (roots : Ident.t list) (ds : declaration list) :
    declaration list =
  (* Map of enumeration constants to the type that defines them *)
  let enums = ref Bindings.empty in
  List.iter
      ( function
      | Decl_Enum (v, es, _) ->
        List.iter (fun e -> enums := Bindings.add e v !enums) es
      | _ ->
        ()
      )
      ds;

  let next (d : declaration) : IdentSet.t =
    let fvs = new freevarClass in
    ignore (visit_decl (fvs :> aslVisitor) d);
    let refs = fvs#vars in
    let refs = IdentSet.union fvs#funs refs in
    let refs = IdentSet.union fvs#tycons refs in
    refs
  in

  (* Map from identifiers to declarations *)
  let decls : (AST.declaration list) Bindings.t = decls_map_of ds in

  (* Construct map from identifier to dependencies. *)
  let next_map = Bindings.map (fun xs -> unionSets (List.map next xs)) decls in
  let get_next (x : Ident.t) : IdentSet.t =
    let ds1 = Option.value (Bindings.find_opt x next_map) ~default:IdentSet.empty in
    let ds2 = Option.fold ~none:IdentSet.empty ~some:IdentSet.singleton (Bindings.find_opt x !enums) in
    IdentSet.union ds1 ds2
  in

  (* Make a sorted list of all identifiers reachable from the roots *)
  let reachable : Ident.t list = reach get_next roots in

  List.concat_map (fun x -> Option.value (Bindings.find_opt x decls) ~default:[]) reachable

(* Topological sort of declarations
 *
 * The declarations should be acyclic
 *)
let topological_sort (ds : declaration list) : declaration list =
  let roots = List.filter_map decl_name ds in
  reachable_decls roots ds

let callers (leaves : Ident.t list) (ds : declaration list) : IdentSet.t =
  let next (d : declaration) : IdentSet.t =
    let fvs = new freevarClass in
    ignore (visit_decl (fvs :> aslVisitor) d);
    fvs#funs
  in

  let decls = decls_map_of ds in
  let fs = List.filter Ident.is_function (keys_of_bindings decls) in
  let callees : IdentSet.t Bindings.t =
    Bindings.map (fun ds -> unionSets (List.map next ds)) decls in
  let callers : IdentSet.t Bindings.t =
    rev_memoize fs (bindings_to_function callees IdentSet.empty) in
  IdentSet.of_list (reach (bindings_to_function callers IdentSet.empty) leaves)

(****************************************************************)
(** {2 Side effect detection}                                   *)
(****************************************************************)

(* All RAM accesses are considered to modify a single RAM variable
 * Note that the name is the same as the __RAM type in the Prelude.
 *)
let dummy_ram_variable = Builtin_idents.ram

class sideEffectClass =
  object
    inherit nopAslVisitor
    val mutable reads = IdentSet.empty
    val mutable writes = IdentSet.empty
    val mutable functions_called = IdentSet.empty
    val mutable throws_exceptions = false

    method sideEffects : IdentSet.t * IdentSet.t * IdentSet.t * bool =
      (reads, writes, functions_called, throws_exceptions)

    method! vlvar x =
      writes <- IdentSet.add x writes;
      SkipChildren

    method! vvar access x =
      if access = Read then reads <- IdentSet.add x reads;
      SkipChildren

    method! vexpr e =
      match e with
      | Expr_TApply (f, _, _, throws) ->
          functions_called <- IdentSet.add f functions_called;
          if throws <> NoThrow then throws_exceptions <- true;
          if Ident.matches ~name:"asl_ram_read" f then begin
            reads <- IdentSet.add dummy_ram_variable reads
          end;
          DoChildren
      | _ -> DoChildren

    method! vstmt s =
      match s with
      | Stmt_TCall (f, _, _, throws, _) ->
          functions_called <- IdentSet.add f functions_called;
          if throws <> NoThrow then throws_exceptions <- true;
          if Ident.matches ~name:"asl_ram_init" f || Ident.matches ~name:"asl_ram_write" f then begin
            writes <- IdentSet.add dummy_ram_variable writes
          end;
          DoChildren
      | Stmt_Throw _ ->
          throws_exceptions <- true;
          DoChildren
      | _ -> DoChildren

    method! vdecl d =
      ( match d with
      | Decl_FunType (f, fty, _)
      | Decl_FunDefn (f, fty, _, _)
      ->  if fty.throws != NoThrow then throws_exceptions <- true;
          DoChildren
      | _
      -> DoChildren
      )

    method! leave_scope (vs : Ident.t list) =
      (* remove reads/writes to local variables *)
      List.iter (fun v -> writes <- IdentSet.remove v writes) vs;
      List.iter (fun v -> reads <- IdentSet.remove v reads) vs
  end

let side_effects_of_decl (d : declaration) : (IdentSet.t * IdentSet.t * IdentSet.t * bool) =
  let se = new sideEffectClass in
  ignore (visit_decl (se :> aslVisitor) d);
  se#sideEffects

let side_effects_of_expr (e : expr) : (IdentSet.t * IdentSet.t * IdentSet.t * bool) =
  let se = new sideEffectClass in
  ignore (visit_expr (se :> aslVisitor) e);
  se#sideEffects

let side_effects_of_lexpr (e : lexpr) : (IdentSet.t * IdentSet.t * IdentSet.t * bool) =
  let se = new sideEffectClass in
  ignore (visit_lexpr (se :> aslVisitor) e);
  se#sideEffects

let identify_impure_funs (isConstant : Ident.t -> bool)
    (isImpurePrim : Ident.t -> bool) (ds : declaration list) : IdentSet.t =
  let is_impure_prim (d : declaration) : bool =
    match d with
    | Decl_BuiltinFunction (f, fty, loc) -> isImpurePrim f
    | _ -> false
  in
  let locally_impure (d : declaration) : bool =
    let (rds, wrs, callees, throws) = side_effects_of_decl d in
    let vrds = IdentSet.filter (fun v -> not (isConstant v)) rds in
    throws || (not (IdentSet.is_empty vrds)) || not (IdentSet.is_empty wrs)
  in

  let impure = ref IdentSet.empty in
  List.iter
    (fun d ->
      match decl_name d with
      | Some x when IdentSet.mem x !impure || is_impure_prim d || locally_impure d
        ->
          impure := IdentSet.add x !impure
      | _ -> ())
    ds;

  (* A function is also treated as impure if we have a function type
   * but no definition
   *)
  let name_of_fundefn (d : AST.declaration) : Ident.t option =
    ( match d with
    | Decl_FunDefn (f, _, _, _) -> Some f
    | _ -> None
    )
  in
  let defined = IdentSet.of_list (List.filter_map name_of_fundefn ds) in
  List.iter (fun d ->
    ( match d with
    | Decl_FunType (f, _, _) when not (IdentSet.mem f defined) ->
        impure := IdentSet.add f !impure
    | _ -> ()
    ))
    ds;

  (* globally impure if it calls a locally impure function *)
  callers (IdentSet.elements !impure) ds

(****************************************************************)
(** {2 Substitutions}                                           *)
(****************************************************************)

(** Performing variable substitutions in expressions and types

    Note that it does not replace type constructors, global constants
    or enumerations in patterns, array indexes and types so this is
    limited to replacing local variables.
    It also does not replace variables used as l-expressions though
    that it easily changed if we think it should.               *)
class substClass (s : expr Bindings.t) =
  object
    inherit nopAslVisitor

    method! vexpr x =
      match x with
      | Expr_Var v -> (
          match Bindings.find_opt v s with
          | Some r -> ChangeTo r
          | None -> DoChildren)
      | _ -> DoChildren
  end

let subst_expr (s : expr Bindings.t) (x : expr) : expr =
  let subst = new substClass s in
  visit_expr subst x

let subst_lexpr (s : expr Bindings.t) (x : lexpr) : lexpr =
  let subst = new substClass s in
  visit_lexpr subst x

let subst_var (s : expr Bindings.t) (kind : access_kind) (x : Ident.t) : Ident.t =
  let subst = new substClass s in
  visit_var subst kind x

let subst_slice (s : expr Bindings.t) (x : slice) : slice =
  let subst = new substClass s in
  visit_slice subst x

let subst_type (s : expr Bindings.t) (x : ty) : ty =
  let subst = new substClass s in
  visit_type subst x

let subst_funtype (s : expr Bindings.t) (x : function_type) : function_type =
  let subst = new substClass s in
  visit_funtype subst [] x

let subst_decl_item (s : expr Bindings.t) (x : decl_item) : decl_item =
  let subst = new substClass s in
  visit_decl_item subst x

(** More flexible substitution class - takes a function instead
    of a binding set.
 *)
class substFunClass (replace : Ident.t -> expr option) =
  object
    inherit nopAslVisitor

    method! vexpr x =
      match x with
      | Expr_Var v -> (
          match replace v with Some r -> ChangeTo r | None -> DoChildren)
      | _ -> DoChildren
  end

let subst_fun_expr (replace : Ident.t -> expr option) (x : expr) : expr =
  let subst = new substFunClass replace in
  visit_expr subst x

let subst_fun_lexpr (replace : Ident.t -> expr option) (x : lexpr) : lexpr =
  let subst = new substFunClass replace in
  visit_lexpr subst x

let subst_fun_slice (replace : Ident.t -> expr option) (x : slice) : slice =
  let subst = new substFunClass replace in
  visit_slice subst x

let subst_fun_type (replace : Ident.t -> expr option) (x : ty) : ty =
  let subst = new substFunClass replace in
  visit_type subst x

(****************************************************************)
(** {2 Expression transformation}                               *)
(****************************************************************)

(** Expression transformation class

    Applies replace function to any subexpression.
    (Especially useful for expressions in types)                *)
class replaceExprClass (replace : expr -> expr option) =
  object
    inherit nopAslVisitor

    method! vexpr x =
      match replace x with Some r -> ChangeTo r | None -> SkipChildren
  end

(****************************************************************)
(** {2 Pretty printing wrappers}                                *)
(****************************************************************)

let pp_unop (x : unop) : string = Utils.to_string2 (Fun.flip FMT.unop x)
let pp_binop (x : binop) : string = Utils.to_string2 (Fun.flip FMT.binop x)
let pp_type (x : ty) : string = Utils.to_string2 (Fun.flip FMT.ty x)
let pp_ixtype (x : ixtype) : string = Utils.to_string2 (Fun.flip FMT.ixtype x)
let pp_expr (x : expr) : string = Utils.to_string2 (Fun.flip FMT.expr x)
let pp_lexpr (x : lexpr) : string = Utils.to_string2 (Fun.flip FMT.lexpr x)
let pp_stmt (x : stmt) : string = Utils.to_string2 (Fun.flip FMT.stmt x)

(****************************************************************)
(** {2 AST expression constructors}                             *)
(****************************************************************)

let type_unit = Type_Tuple []
let type_integer = Type_Integer None
let type_bool = Type_Constructor (boolean_ident, [])
let type_real = Type_Constructor (real_ident, [])
let type_string = Type_Constructor (string_ident, [])
let type_bits (n : expr) = Type_Bits (n, [])
let type_sintN (n : expr) = Type_Constructor (sintN, [n])

let asl_false = AST.Expr_Var false_ident
let asl_true = AST.Expr_Var true_ident

let mk_litint (x : int) : AST.expr = Expr_Lit (VInt (Z.of_int x))
let mk_litbigint (x : Z.t) : AST.expr = Expr_Lit (VInt x)
let mk_litstr (x : string) : AST.expr = Expr_Lit (VString x)

let minus_one = Expr_Lit (VInt Z.minus_one)
let zero      = Expr_Lit (VInt Z.zero)
let one       = Expr_Lit (VInt Z.one)
let two       = mk_litint 2

let empty_bits = Expr_Lit (VBits Primops.empty_bits)

let mk_unop (op : Ident.t) (tys : AST.expr list) (x : AST.expr) : AST.expr =
  Expr_TApply (op, tys, [x], NoThrow)

let mk_binop (op : Ident.t) (tys : AST.expr list) (x : AST.expr) (y : AST.expr) : AST.expr =
  Expr_TApply (op, tys, [x; y], NoThrow)

(** Construct "!x" *)
let mk_not (x : AST.expr) : AST.expr =
  if x = asl_false then asl_true
  else if x = asl_true then asl_false
  else mk_unop not_bool [] x

(** Construct "x && y" *)
let mk_and (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = asl_false then asl_false
  else if x = asl_true then y
  else if y = asl_true then x
  else mk_binop lazy_and_bool [] x y

(** Construct "x || y" *)
let mk_or (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = asl_true then asl_true
  else if x = asl_false then y
  else if y = asl_false then x
  else mk_binop lazy_or_bool [] x y

(** Construct "x --> y" *)
let mk_implies (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = asl_false then asl_true
  else if x = asl_true then y
  else if y = asl_false then mk_not x
  else mk_binop implies_bool [] x y

(** Construct "eq_enum(x, y)" *)
let mk_eq_enum (x : AST.expr) (y : AST.expr) : AST.expr = mk_binop eq_enum [] x y

(** Construct "eq_int(x, y)" *)
let mk_eq_int (x : AST.expr) (y : AST.expr) : AST.expr = mk_binop eq_int [] x y

(** Construct "ne_int(x, y)" *)
let mk_ne_int (x : AST.expr) (y : AST.expr) : AST.expr = mk_binop ne_int [] x y

(** Construct "le_int(x, y)" *)
let mk_le_int (x : AST.expr) (y : AST.expr) : AST.expr = mk_binop le_int [] x y

(** Construct "lt_int(x, y)" *)
let mk_lt_int (x : AST.expr) (y : AST.expr) : AST.expr = mk_binop lt_int [] x y

(** Construct "add_int(x, y)" *)
let mk_add_int (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = zero then y
  else if y = zero then x
  else mk_binop add_int [] x y

(** Construct "sub_int(x, y)" *)
let mk_sub_int (x : AST.expr) (y : AST.expr) : AST.expr =
  if y = zero then x
  else mk_binop sub_int [] x y

(** Construct "neg_int(x)" *)
let mk_neg_int (x : AST.expr) : AST.expr =
  mk_unop neg_int [] x

(** Construct "mul_int(x, y)" *)
let mk_mul_int (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = one then y
  else if y = one then x
  else if x = minus_one then mk_neg_int y
  else if y = minus_one then mk_neg_int x
  else mk_binop mul_int [] x y

(** Construct "zrem_int(x, y)" *)
let mk_zrem_int (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop zrem_int [] x y

(** Construct "pow_int_int(x, y)" *)
let mk_pow_int_int (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = zero then zero
  else if x = one then one
  else if y = zero then one
  else if y = one then x
  else mk_binop pow_int_int [] x y

(** Construct "exact_div_int(x, y)" *)
let mk_exact_div_int (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop exact_div_int [] x y

(** Construct "Max(x, y)" *)
let mk_max_int (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = y then x
  else mk_binop max [] x y

(** Construct "Min(x, y)" *)
let mk_min_int (x : AST.expr) (y : AST.expr) : AST.expr =
  if x = y then x
  else mk_binop min [] x y

(** Construct "eq_bits{w}(x, y)" *)
let mk_eq_bits (w : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop eq_bits [w] x y

(** Construct "add_bits{w}(x, y)" *)
let mk_add_bits (w : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop add_bits [w] x y

(** Construct "sub_bits{w}(x, y)" *)
let mk_sub_bits (w : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop sub_bits [w] x y

(** Construct "mul_bits{w}(x, y)" *)
let mk_mul_bits (w : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop mul_bits [w] x y

(** Construct "in_mask{w}(x, y)" *)
let mk_in_mask (w : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  mk_binop in_mask [w] x y

(** Construct "and_bits{N}(x, y)" *)
let mk_and_bits (n : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  ( match (x, y) with
  | (Expr_TApply (i, _, _, _), _) when Ident.equal i ones_bits -> y
  | (_, Expr_TApply (i, _, _, _)) when Ident.equal i ones_bits -> x
  | _ -> mk_binop and_bits [n] x y
  )

(** Construct "or_bits{N}(x, y)" *)
let mk_or_bits (n : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  ( match (x, y) with
  | (Expr_TApply (i, _, _, _), _) when Ident.equal i zeros_bits -> y
  | (_, Expr_TApply (i, _, _, _)) when Ident.equal i zeros_bits -> x
  | _ -> mk_binop or_bits [n] x y
  )

(** Construct "lsr_bits{N}(x, y)" *)
let mk_lsr_bits (n : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  if y = zero then
    x
  else
    mk_binop lsr_bits [n] x y

(** Construct "lsl_bits{N}(x, y)" *)
let mk_lsl_bits (n : AST.expr) (x : AST.expr) (y : AST.expr) : AST.expr =
  if y = zero then
    x
  else
    mk_binop lsl_bits [n] x y

(** Construct "zeros_bits{N}(N)" *)
let mk_zero_bits (n : AST.expr) : AST.expr =
  mk_unop zeros_bits [n] n

(** Construct "ones_bits{N}(N)" *)
let mk_ones_bits (n : AST.expr) : AST.expr =
  mk_unop ones_bits [n] n

(** Construct "asl_extract_bits{w,n}(x, lo, w)" *)
let mk_bits_select (w : AST.expr) (n : AST.expr) (x : AST.expr) (lo : AST.expr) : AST.expr =
  Expr_TApply (asl_extract_bits, [ w; n ], [ x; lo; w ], NoThrow)

(** Construct "zero_extend_bits{w, n}(x, n)" *)
let mk_zero_extend_bits (w : AST.expr) (n : AST.expr) (x : AST.expr) : AST.expr =
  if w = n then
    x
  else
    Expr_TApply (zero_extend_bits, [ w; n ], [ x; n ], NoThrow)

(** Construct "mk_mask{n}(w, n)" which is equivalent to
 *  'ZeroExtend{n}(Ones(w), n)'
 *)
let mk_mask (w : AST.expr) (n : AST.expr) =
  if w = n then
    mk_ones_bits n
  else
    Expr_TApply (mk_mask, [n], [w; n], NoThrow)

let mk_not_bits (m : AST.expr) (n : AST.expr) : AST.expr =
  Expr_TApply (not_bits, [m], [n], NoThrow)

(** Construct "(0 + x1) + ... + xn" *)
let mk_add_ints (xs : AST.expr list) : AST.expr =
  List.fold_left mk_add_int zero xs

(** Construct "(z * x1) * ... * xn" *)
let mk_mul_ints (z : AST.expr) (xs : AST.expr list) : AST.expr =
  List.fold_left mk_mul_int z xs

(** Construct "(TRUE && x1) && ... && xn" *)
let mk_ands (xs : AST.expr list) : AST.expr =
  List.fold_left mk_and asl_true xs

(** Construct "(FALSE || x1) || ... || xn" *)
let mk_ors  (xs : AST.expr list) : AST.expr =
  List.fold_left mk_or asl_false xs

(** Construct "cvt_int_bits{n}(x, n)" *)
let mk_cvt_int_bits (n : AST.expr) (x : AST.expr) : AST.expr =
  Expr_TApply (cvt_int_bits, [ n ], [ x; n ], NoThrow)

(****************************************************************)
(** {2 Let expressions and statements}                          *)
(****************************************************************)

type binding = (Ident.t * AST.ty * AST.expr)
type check = (AST.expr * Loc.t)

(** Construct nested let-expressions from a list of bindings
 *
 *     mk_let_exprs [(x, tx, ex); (y, ty, ey)] e
 *   =
 *     let x:tx = ex in (let y:ty = ey in e)
 *)
let rec mk_let_exprs (bindings : binding list) (e : AST.expr) : AST.expr =
  ( match bindings with
  | [] -> e
  | ((v, ty, e') :: bs) -> AST.Expr_Let(v, ty, e', mk_let_exprs bs e)
  )

(** Construct assignments from a list of bindings
 *
 *     mk_assigns loc [(x, tx, ex); (y, ty, ey)]
 *   =
 *     let x : tx = ex;
 *     let y : ty = ey;
 *)
let mk_assigns (loc : Loc.t) (bindings : binding list) : AST.stmt list =
  List.map (fun (v, ty, e) ->
    AST.Stmt_VarDecl (true, DeclItem_Var (v, Some ty), e, loc))
    bindings

(****************************************************************)
(** {2 Assert expressions and statements}                       *)
(****************************************************************)

(* Construct nested assert-expressions from a list of checks
 *
 *     mk_assert [(x, locx); (y, locy)] e
 *   =
 *     __assert x __in (__assert y in e)
 *)
let rec mk_assert_exprs (checks : (AST.expr * Loc.t) list) (e : AST.expr) : AST.expr =
  ( match checks with
  | [] -> e
  | ((c, loc) :: cs) -> AST.Expr_Assert (c, mk_assert_exprs cs e, loc)
  )

(* Construct assertion statements from a list of checks
 *
 *     mk_assert [(x, locx); (y, locy)] e
 *   =
 *     assert x;
 *     assert y;
 *)
let mk_assert_stmts (checks : (AST.expr * Loc.t) list) : AST.stmt list =
  List.map (fun (c, loc) -> AST.Stmt_Assert (c, loc)) checks

(****************************************************************)
(** {2 Safe expressions}                                        *)
(****************************************************************)

(** Conservatively test whether an expression is safe to evaluate more than
 *  once or not to evaluate at all. That is:
 *  - does it have side effects?
 *  - can it throw an exception?
 *  - can it cause a runtime error?
 *  - is it expensive to evaluate?
 *)
let rec is_safe_to_replicate (x : expr) : bool =
  ( match x with
  (* trivial, atomic expressions *)
  | Expr_Var _
  | Expr_Lit _
  -> true

  (* recursive cases *)
  | Expr_Let (_, _, e, b) -> is_safe_to_replicate e && is_safe_to_replicate b
  | Expr_Field (e, f) -> is_safe_to_replicate e
  | Expr_Fields (e, fs) -> is_safe_to_replicate e
  | Expr_In (e, p) -> is_safe_to_replicate e
  | Expr_Tuple es -> List.for_all is_safe_to_replicate es
  | Expr_Array (e, i) -> is_safe_to_replicate e && is_safe_to_replicate i
  | Expr_Concat (ws, es) -> List.for_all is_safe_to_replicate es

  | _
  -> false
  )

(** Make an expression safe to replicate by introducing a let-expression
 *  if needed.
 *
 *  An expression is safe to replicate if it has no side effects, doesn't
 *  throw exceptions and is cheap.
 *
 *  This function takes a continuation 'f' that is passed the resulting
 *  safe expression.
 *  - If the expression is already safe to replicate, then return '<f e>'.
 *  - If the expression is not safe to replicate, then return
 *    '__let tmp : ty = e __in <f tmp>'
 *
 *  The nameSupply is used to generate a fresh variable.
 *)
let mk_expr_safe_to_replicate (supply : nameSupply) (e : expr) (ty : AST.ty) (f : expr -> expr) : expr =
  if is_safe_to_replicate e then
    f e
  else
    let v = supply#fresh in
    Expr_Let (v, ty, e, f (Expr_Var v))

(****************************************************************)
(** {2 Misc}                                                    *)
(****************************************************************)

(** Length of bitstring or mask literal.

    ASL bit and mask literals allow spaces to be included - these
    do not count towards the length of the literal.
 *)
let masklength (x : string) : int =
  let r = ref 0 in
  String.iter (function ' ' -> () | _ -> r := !r + 1) x;
  !r

let masklength_expr (x : string) : AST.expr =
  mk_litint (masklength x)

(** Test whether a function returns a tuple (of 2 or more elements). *)
let isTupleType (t : AST.ty) : bool =
  match t with
  | AST.Type_Tuple (_ :: _ :: _) -> true
  | _ -> false

(** Deconstruct a tuple type (return `[t]` if not a tuple type *)
let tupleTypes (t : AST.ty) : AST.ty list =
  match t with
  | AST.Type_Tuple ts -> ts
  | _ -> [t]

(** Bitwidth of type (which is expected to be a bitvector) *)
let width_of_type (ty : AST.ty) : AST.expr option =
  ( match ty with
  | Type_Bits (n, _)
    -> Some n
  | _
    -> None
  )

(** Is an expression a literal constant? *)
let is_literal_constant (x : expr) : bool =
  ( match x with
  | Expr_Lit _ -> true
  | _          -> false
  )

(** Convert an L-expression to an expression *)
let rec lexpr_to_expr (x : AST.lexpr) : AST.expr option =
  ( match x with
  | LExpr_Var v ->
    Some (Expr_Var v)
  | LExpr_Field (l, f) ->
    Option.bind (lexpr_to_expr l) (fun e ->
    Some (Expr_Field (e, f)))
  | LExpr_Fields (l, fs) ->
    Option.bind (lexpr_to_expr l) (fun e ->
    Some (Expr_Fields (e, fs)))
  | LExpr_Slices (t, l, ss) ->
    Option.bind (lexpr_to_expr l) (fun e ->
    Some (Expr_Slices (t, e, ss)))
  | LExpr_BitTuple (ws, ls) ->
    Option.bind (lexprs_to_exprs ls) (fun es ->
    Some (Expr_Concat (ws, es)))
  | LExpr_Tuple ls ->
    Option.bind (lexprs_to_exprs ls) (fun es ->
    Some (Expr_Tuple es))
  | LExpr_Array (l, ix) ->
    Option.bind (lexpr_to_expr l) (fun e ->
    Some (Expr_Array (e, ix)))
  | LExpr_ReadWrite (getter, setter, tes, es, throws) ->
    Some (Expr_TApply (getter, tes, es, throws))

  | LExpr_Wildcard
  | LExpr_Write _
    -> None
  )

and lexprs_to_exprs (xs : AST.lexpr list) : AST.expr list option =
  Utils.flatten_map_option (lexpr_to_expr) xs

(** Get base type of index type *)
let ixtype_basetype (ty : AST.ixtype) : AST.ty =
  match ty with
  | Index_Enum tc -> Type_Constructor (tc, [])
  | Index_Int sz -> type_integer

(** Move function definitions to the end of the list. This is to allow
    calling the functions before they are defined. *)
let hoist_prototypes (ds : AST.declaration list) : AST.declaration list =
  let pre : AST.declaration list ref = ref [] in
  let post : AST.declaration list ref = ref [] in
  List.iter
    (fun d ->
      match d with
      | AST.Decl_FunDefn _ -> post := d :: !post
      | AST.Decl_FunType _ -> pre := d :: !pre
      | _ -> pre := d :: !pre)
    ds;
  (List.rev !pre) @ (List.rev !post)

(****************************************************************
 * End
 ****************************************************************)
